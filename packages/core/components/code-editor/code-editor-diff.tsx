// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
// this code is largerly generated by ai so it might not be following best practices best it does seem functional, we
// should test this functionality heavily any once we are comfortable with it working, we should writing a bunch of
// playwright test for the known functionality and then heavily review and refactor this file as needed
// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------
import Button, { ButtonColor, ButtonSize } from '$/core/components/button';
import styles from '$/core/components/code-editor/code-editor.module.css';
import {
  CodeEditorChunkDecision,
  CodeEditorDiffType,
  type CodeEditorLanguageConfiguration,
  defaultExtensions,
} from '$/core/components/code-editor/utils';
import type { CommonDataAttributes } from '$/core/types/generic';
import { loggerUtils } from '$/core/utils/logger';
import { tailwindUtils } from '$/core/utils/tailwind';
import { lintGutter, linter } from '@codemirror/lint';
import {
  type Chunk,
  MergeView,
  acceptChunk,
  getChunks,
  getOriginalDoc,
  rejectChunk,
  unifiedMergeView,
} from '@codemirror/merge';
import { EditorState, type Extension } from '@codemirror/state';
import { EditorView, type ViewUpdate } from '@codemirror/view';
import { For, type JSX, Show, createEffect, createSignal, mergeProps, onMount, splitProps } from 'solid-js';

export type CodeEditorChunkDecisionResult = {
  index: number;
  decision: CodeEditorChunkDecision;
  newOriginalContent: string;
  newModifiedContent?: string;
};

export type CodeEditorDiffProps = JSX.HTMLAttributes<HTMLDivElement> &
  CommonDataAttributes & {
    doc: string;
    suggestedDoc: string;
    diffType?: CodeEditorDiffType;
    language?: CodeEditorLanguageConfiguration;
    extensions?: Extension[];
    readonly?: boolean;
    isBorderless?: boolean;
    onChunkDecision?: (result: CodeEditorChunkDecisionResult) => void;
  };

const CodeEditorDiff = (passedProps: CodeEditorDiffProps) => {
  const [props, restOfProps] = splitProps(
    mergeProps(
      {
        doc: '',
        suggestedDoc: '',
        diffType: CodeEditorDiffType.SIDE_BY_SIDE,
        extensions: [],
        readonly: false,
        isBorderless: false,
      },
      passedProps,
    ),
    [
      'class',
      'doc',
      'suggestedDoc',
      'diffType',
      'extensions',
      'readonly',
      'language',
      'isBorderless',
      'onChunkDecision',
    ],
  );

  const [containerElementRef, setContainerElementRef] = createSignal<HTMLDivElement | undefined>();
  const [mergeView, setMergeView] = createSignal<MergeView | EditorView>();
  const [chunks, setChunks] = createSignal<Chunk[]>([]);
  const [chunkPositions, setChunkPositions] = createSignal<{ top: number; chunkIndex: number }[]>([]);
  const [lastDoc, setLastDoc] = createSignal<string>('');
  const [lastSuggestedDoc, setLastSuggestedDoc] = createSignal<string>('');
  const [shouldUpdatePositions, setShouldUpdatePositions] = createSignal(false);

  const getDocumentVersions = (view: EditorView) => {
    const originalDoc = getOriginalDoc(view.state);
    const modifiedDoc = view.state.doc;

    return {
      original: originalDoc.toString(),
      modified: modifiedDoc.toString(),
    };
  };

  const updateChunks = () => {
    const view = mergeView();

    if (!view) {
      setChunks([]);
      setChunkPositions([]);
      return;
    }

    if (props.diffType === CodeEditorDiffType.UNIFIED) {
      const unifiedView = view as EditorView;
      const chunksData = getChunks(unifiedView.state);

      if (chunksData) {
        setChunks([...chunksData.chunks]);
        updateChunkPositions(unifiedView, chunksData.chunks);
      }
    } else if (props.diffType === CodeEditorDiffType.SIDE_BY_SIDE) {
      const sideBySideView = view as MergeView;
      const chunksData = getChunks(sideBySideView.b.state);

      if (chunksData) {
        setChunks([...chunksData.chunks]);
        updateChunkPositions(sideBySideView.b, chunksData.chunks);
      }
    }
  };

  const updateChunkPositions = (view: EditorView, chunksArray: readonly Chunk[]) => {
    const positions: { top: number; chunkIndex: number }[] = [];

    // Check if editor DOM is ready
    const editorRect = view.dom?.getBoundingClientRect();

    if (!view.dom || !editorRect || editorRect.height === 0) {
      // we use a request animation frame to ensure the editor is updated so the chunks are positioned correctly
      // positions
      requestAnimationFrame(() => updateChunkPositions(view, chunksArray));
      return;
    }

    chunksArray.forEach((chunk, index) => {
      try {
        // Get the line block for the start of the chunk
        const lineBlock = view.lineBlockAt(chunk.fromB);
        const containerRect = containerElementRef()?.getBoundingClientRect();

        if (containerRect && editorRect.height > 0) {
          // Calculate the relative position within the container
          const relativeTop = lineBlock.top;

          positions.push({
            top: relativeTop,
            chunkIndex: index,
          });
        }
      } catch (error) {
        loggerUtils.error('Error calculating chunk position:', error);
      }
    });

    setChunkPositions(positions);
  };

  // Create update listener extension for chunk updates
  const createChunkUpdateListener = () => {
    return EditorView.updateListener.of((update: ViewUpdate) => {
      if (update.docChanged || update.viewportChanged) {
        // Update chunks when document or viewport changes
        setShouldUpdatePositions(true);
      }
    });
  };

  const handleAcceptChunk = (chunkIndex: number) => {
    const view = mergeView();

    if (!view) {
      return;
    }

    try {
      if (props.diffType === CodeEditorDiffType.UNIFIED) {
        const targetView = view as EditorView;
        const chunksData = getChunks(targetView.state);

        if (chunksData?.chunks[chunkIndex]) {
          const chunk = chunksData.chunks[chunkIndex];
          acceptChunk(targetView, chunk.fromB);

          const { original, modified } = getDocumentVersions(targetView);
          props.onChunkDecision?.({
            index: chunkIndex,
            decision: CodeEditorChunkDecision.ACCEPT,
            newOriginalContent: original,
            newModifiedContent: modified,
          });
        }
      } else {
        // For side-by-side view, manually accept the chunk by copying from B to A
        const sideBySideView = view as MergeView;
        const chunksData = getChunks(sideBySideView.b.state);

        if (chunksData?.chunks[chunkIndex]) {
          const chunk = chunksData.chunks[chunkIndex];

          // Get the text from the B editor (suggested changes)
          const chunkText = sideBySideView.b.state.doc.sliceString(chunk.fromB, chunk.toB);

          // Apply the change to the A editor (original)
          const transaction = sideBySideView.a.state.update({
            changes: {
              from: chunk.fromA,
              to: chunk.toA,
              insert: chunkText,
            },
          });

          sideBySideView.a.dispatch(transaction);
          props.onChunkDecision?.({
            index: chunkIndex,
            decision: CodeEditorChunkDecision.ACCEPT,
            newOriginalContent: sideBySideView.a.state.doc.toString(),
            newModifiedContent: sideBySideView.b.state.doc.toString(),
          });
        }
      }

      // Trigger chunk update via reactive signal
      setShouldUpdatePositions(true);
    } catch (error) {
      loggerUtils.error('Error accepting chunk:', error);
    }
  };

  const handleRejectChunk = (chunkIndex: number) => {
    const view = mergeView();

    if (!view) {
      return;
    }

    try {
      if (props.diffType === CodeEditorDiffType.UNIFIED) {
        const targetView = view as EditorView;
        const chunksData = getChunks(targetView.state);

        if (chunksData?.chunks[chunkIndex]) {
          const chunk = chunksData.chunks[chunkIndex];
          rejectChunk(targetView, chunk.fromB);

          const { original, modified } = getDocumentVersions(targetView);
          props.onChunkDecision?.({
            index: chunkIndex,
            decision: CodeEditorChunkDecision.REVERT,
            newOriginalContent: original,
            newModifiedContent: modified,
          });
        }
      } else {
        // For side-by-side view, manually reject the chunk by keeping the original text in A
        // and removing the suggested change from B
        const sideBySideView = view as MergeView;
        const chunksData = getChunks(sideBySideView.b.state);

        if (chunksData?.chunks[chunkIndex]) {
          const chunk = chunksData.chunks[chunkIndex];

          // Get the original text from the A editor
          const originalText = sideBySideView.a.state.doc.sliceString(chunk.fromA, chunk.toA);

          // Replace the suggested change in B editor with the original text
          const transaction = sideBySideView.b.state.update({
            changes: {
              from: chunk.fromB,
              to: chunk.toB,
              insert: originalText,
            },
          });

          sideBySideView.b.dispatch(transaction);
          props.onChunkDecision?.({
            index: chunkIndex,
            decision: CodeEditorChunkDecision.REVERT,
            newOriginalContent: sideBySideView.a.state.doc.toString(),
            newModifiedContent: sideBySideView.b.state.doc.toString(),
          });
        }
      }

      // Trigger chunk update via reactive signal
      setShouldUpdatePositions(true);
    } catch (error) {
      loggerUtils.error('Error rejecting chunk:', error);
    }
  };

  // Handle position updates via reactive signal
  createEffect(() => {
    if (shouldUpdatePositions()) {
      updateChunks();
      setShouldUpdatePositions(false);
    }
  });

  createEffect(function updateDiffContent() {
    const view = mergeView();

    if (!view) {
      return;
    }

    // Only update if the document content has actually changed from props
    const docChanged = props.doc !== lastDoc();
    const suggestedDocChanged = props.suggestedDoc !== lastSuggestedDoc();

    if (!docChanged && !suggestedDocChanged) {
      return;
    }

    if (props.diffType === CodeEditorDiffType.SIDE_BY_SIDE) {
      const sideBySideView = view as MergeView;

      if (docChanged && sideBySideView.a.state.doc.toString() !== props.doc) {
        const aTransaction = sideBySideView.a.state.update({
          changes: {
            from: 0,
            to: sideBySideView.a.state.doc.length,
            insert: props.doc,
          },
        });
        sideBySideView.a.dispatch(aTransaction);
      }

      if (suggestedDocChanged && sideBySideView.b.state.doc.toString() !== props.suggestedDoc) {
        const bTransaction = sideBySideView.b.state.update({
          changes: {
            from: 0,
            to: sideBySideView.b.state.doc.length,
            insert: props.suggestedDoc,
          },
        });
        sideBySideView.b.dispatch(bTransaction);
      }
    } else {
      const unifiedView = view as EditorView;

      if (suggestedDocChanged && unifiedView.state.doc.toString() !== props.suggestedDoc) {
        const transaction = unifiedView.state.update({
          changes: {
            from: 0,
            to: unifiedView.state.doc.length,
            insert: props.suggestedDoc,
          },
        });
        unifiedView.dispatch(transaction);
      }
    }

    setLastDoc(props.doc);
    setLastSuggestedDoc(props.suggestedDoc);
  });

  // Add scroll listener to update positions when scrolling
  createEffect(() => {
    const view = mergeView();

    if (!view) {
      return;
    }

    let targetView: EditorView;

    if (props.diffType === CodeEditorDiffType.UNIFIED) {
      targetView = view as EditorView;
    } else {
      targetView = (view as MergeView).b;
    }

    const currentChunks = chunks();

    if (currentChunks.length > 0) {
      const handleScroll = () => {
        updateChunkPositions(targetView, currentChunks);
      };

      // Add scroll listener to the editor's scroll container
      const scrollContainer = targetView.scrollDOM;
      scrollContainer.addEventListener('scroll', handleScroll);

      return () => {
        scrollContainer.removeEventListener('scroll', handleScroll);
      };
    }
  });

  onMount(() => {
    const currentContainerElementRef = containerElementRef();

    if (!currentContainerElementRef) {
      loggerUtils.error('container element reference is missing');

      return;
    }

    // Initialize the last doc values
    setLastDoc(props.doc);
    setLastSuggestedDoc(props.suggestedDoc);

    const chunkUpdateListener = createChunkUpdateListener();

    const extensions: Extension[] = [
      ...defaultExtensions,
      chunkUpdateListener,
      EditorView.theme({
        '&': {
          height: '100%',
          width: '100%',
        },
        '.cm-scroller': {
          height: '100%',
        },
        '.cm-merge-view': {
          height: '100%',
        },
        '.cm-merge-view .cm-editor': {
          height: '100%',
        },
      }),
      ...props.extensions,
    ];

    if (props.language) {
      extensions.push(props.language.extension);

      if (props.language.linter) {
        extensions.push(lintGutter());
        extensions.push(
          linter(props.language.linter, {
            delay: 750,
          }),
        );
      }
    }

    const aState = EditorState.create({
      doc: props.doc,
      extensions: [...extensions, EditorState.readOnly.of(true), EditorView.editable.of(false)],
    });

    const bState = EditorState.create({
      doc: props.suggestedDoc,
      extensions: [...extensions, EditorState.readOnly.of(props.readonly), EditorView.editable.of(!props.readonly)],
    });

    if (props.diffType === CodeEditorDiffType.SIDE_BY_SIDE) {
      const mergeConfig = {
        a: {
          doc: props.doc,
          extensions: [...extensions, EditorState.readOnly.of(true), EditorView.editable.of(false)],
        },
        b: {
          doc: props.suggestedDoc,
          extensions: [...extensions, EditorState.readOnly.of(props.readonly), EditorView.editable.of(!props.readonly)],
        },
        parent: currentContainerElementRef,
      };

      setMergeView(new MergeView(mergeConfig));

      // Schedule initial chunk positioning after editor is mounted
      requestAnimationFrame(() => {
        setShouldUpdatePositions(true);
      });
    } else {
      // For unified view, use unifiedMergeView function with chunk operations
      const unifiedView = unifiedMergeView({
        original: props.doc,
        mergeControls: false,
      });

      const editorView = new EditorView({
        state: EditorState.create({
          doc: props.suggestedDoc,
          extensions: [...extensions, unifiedView],
        }),
        parent: currentContainerElementRef,
      });

      setMergeView(editorView);

      // Schedule initial chunk positioning after editor is mounted
      requestAnimationFrame(() => {
        setShouldUpdatePositions(true);
      });
    }
  });

  return (
    <div class="relative">
      <div
        {...restOfProps}
        class={tailwindUtils.merge(styles.codeEditor, props.class, {
          [styles.borderless]: props.isBorderless,
        })}
        ref={setContainerElementRef}
      />
      <Show when={chunkPositions().length > 0}>
        <For each={chunkPositions()}>
          {(position) => (
            <div
              class="absolute flex gap-xs z-10 right-3xs"
              style={{
                top: `${position.top + 10}px`,
              }}
            >
              <Button
                color={ButtonColor.SUCCESS}
                size={ButtonSize.SMALL}
                onClick={() => handleAcceptChunk(position.chunkIndex)}
              >
                Accept
              </Button>
              <Button
                color={ButtonColor.DANGER}
                size={ButtonSize.SMALL}
                onClick={() => handleRejectChunk(position.chunkIndex)}
              >
                Reject
              </Button>
            </div>
          )}
        </For>
      </Show>
    </div>
  );
};

export default CodeEditorDiff;
